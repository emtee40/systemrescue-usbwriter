# no shebang supported here
# can only be directly called with the correct shell (=packaged version of bash)
#
# sysrescueusbwriter - write an iso image of SystemRescue to USB media
# 
# Author: Gerd v. Egidy
# SPDX-License-Identifier: GPL-3.0-or-later
#
# https://gitlab.com/systemrescue/systemrescue-sources/-/issues/284

BINDIR="${APPDIR}/usr/bin"

# abort on failures
set -o errexit -o pipefail -o noclobber -o nounset

print_help()
{
    echo "sysrescueusbwriter - write an iso image of SystemRescue to USB media"
    echo ""
    echo "Usage:"
    echo "sysrescueusbwriter-x86_64.AppImage [OPTIONS] <ISO-FILE>"
    echo ""
    echo "<ISO-FILE>                     ISO image of SystemRescue"
    echo ""
    echo "Options:"
    echo ""
    echo "-t|--targetdev=<DEVICE-PATH>   Device file of the USB media you want to write to."
    echo "                               Something like /dev/sdb."
    echo "                               A text UI to select a likely device is shown if missing."
    echo ""
    echo "-e|--tmpdir=<TMPDIR>           Use the given directory for storing temporary files."
    echo "                               You need enough space there for unpacking the whole"
    echo "                               iso image. Defaults to the TMPDIR environment variable."
    echo ""
    echo "-l|--licenses                  Show licenses of all programs packaged in the AppImage."
    echo "                               Use 'e' to view a file and 'q' to quit."
    echo "                               Showing the licenses overrides other parameters."
    echo ""
    echo "-h|--help                      Show this help. Overrides other parameters."
    echo ""
    echo "See https://gitlab.com/systemrescue/systemrescue-sources/-/issues/284 for details."
    
    return
}

# error while parsing commandline parameters
argument_error()
{
    echo "$1"
    echo
    echo "---------------------------------"
    echo
    print_help
    exit 2
}

show_licenses()
{
    # nnn will change the current directory when browsing
    # this means we can't use any of our packaged binaries
    # so less as the "editor" used for showing the licenses comes from the host system

    if ! command -v less &>/dev/null ; then
        echo "ERROR: 'less' command not found. It is required for viewing licenses"
        exit 1
    fi
    
    EDITOR=less "${BINDIR}/nnn" "${APPDIR}/usr/share/licenses/"
}

parse_args()
{
    # adapted from https://stackoverflow.com/a/29754866 by Robert Siemer
    # version edited Mar 4 '21 at 0:11, licensed under CC BY-SA 4.0 due to Stackoverflow Terms of Service
    # https://creativecommons.org/licenses/by-sa/4.0/

    # show help when no arguments given
    [[ $# -eq 0 ]] && { print_help ; exit 0 ; }
    
    # -allow a command to fail with !’s side effect on errexit
    # -use return value from ${PIPESTATUS[0]}, because ! hosed $?
    ! "${BINDIR}/getopt" --test > /dev/null 
    if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
        echo 'ERROR: `getopt --test` failed in this environment'
        exit 1
    fi

    local OPTIONS="t:e:lh"
    local LONGOPTS="targetdev:,tmpdir:,license,licenses,help"

    # option variables as globals, set to default values
    declare -g TARGETDEV=""
    declare -g ISOIMAGE=""
    declare -g VERBOSE=""
    declare -g TMPDIR
    
    # -regarding ! and PIPESTATUS see above
    # -temporarily store output to be able to check for errors
    # -activate quoting/enhanced mode (e.g. by writing out “--options”)
    # -pass arguments only via   -- "$@"   to separate them correctly
    ! PARSED=$("${BINDIR}/getopt" --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        # e.g. return value is 1
        #  then getopt has complained about wrong arguments to stdout
        echo
        print_help
        exit 2
    fi
    # read getopt’s output this way to handle the quoting right:
    eval set -- "$PARSED"

    while true; do
        case "$1" in
            -t|--targetdev)
                TARGETDEV="$2"
                shift 2
                ;;
            -e|--tmpdir)
                TMPDIR="$2"
                shift 2
                ;;
            -h|--help)
                print_help
                exit 0
                ;;
            -l|--license|--licenses)
                show_licenses
                exit 0
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "ERROR: Argument parsing logic bug"
                exit 2
                ;;
        esac
    done

    # handle positional arguments 
    if [[ $# -lt 1 ]]; then
        argument_error "ERROR: iso image option missing or empty"
        exit 1
    fi
    if [[ $# -gt 1 ]]; then
        argument_error "ERROR: too many positional arguments"
        exit 1
    fi
    ISOIMAGE="$1"
    
    [[ -z "$ISOIMAGE" ]] && argument_error "ERROR: iso image option missing or empty"

    if [[ "$ISOIMAGE" =~ ^[^/] ]]; then
        # path relative to the dir we were originally called from
        ISOIMAGE="${OWD}/${ISOIMAGE}"
    fi

    if [[ -n "$TARGETDEV" ]] && [[ "$TARGETDEV" =~ ^[^/] ]]; then
        # path relative to the dir we were originally called from
        TARGETDEV="${OWD}/${TARGETDEV}"
    fi
    
    return
}

check_iso()
{
    if ! [[ -f "$ISOIMAGE" ]]; then
        echo "ERROR: No such file: $ISOIMAGE"
        exit 1
    fi

    if ! [[ -r "$ISOIMAGE" ]]; then
        echo "ERROR: not enough permissions to read $ISOIMAGE"
        exit 2
    fi

    # check if we really have an iso file as source and not something else
    if ! "${BINDIR}/xorriso" -drive_access "shared:readonly" -indev "${ISOIMAGE}" -toc >/dev/null 2>&1 ||
        "${BINDIR}/xorriso" -drive_access "shared:readonly" -indev "${ISOIMAGE}" -toc 2>&1 | "${BINDIR}/grep" -E "(is blank|Drive address .* rejected)"; then
        echo "ERROR: $ISOIMAGE is not a valid ISO file"
        exit 3
    fi

    declare -g ISOSIZE=$("${BINDIR}/stat" --format=%s "$ISOIMAGE")
    
    # TODO: opportunistic checkisomd5 verify

    return
}

check_targetdev()
{
    if ! [[ -e "$TARGETDEV" ]]; then
        echo "ERROR: target device $TARGETDEV doesn't exist"
        exit 1
    fi

    if ! [[ -b "$TARGETDEV" ]]; then
        echo "ERROR: target device not a block device: $TARGETDEV"
        exit 1
    fi

    if ! [[ -r "$TARGETDEV" && -w "$TARGETDEV" ]]; then
        echo "ERROR: not enough permissions to access $TARGETDEV"
        exit 2
    fi

    TARGETDEVSIZE=$("${BINDIR}/lsblk" -o SIZE --bytes --noheadings --nodeps "$TARGETDEV")
    # require gracious 50 MB tolerance to account for filesystem metadata and partitioning
    if [[ "${TARGETDEVSIZE}" -lt $[$ISOSIZE+52428800] ]]; then
        echo "ERROR: $TARGETDEV is too small for the given iso image"
        exit 2
    fi

    if "${BINDIR}/lsblk" -o PKNAME --noheadings --nodeps "$TARGETDEV" | "${BINDIR}/grep" -q -E -v "^\$" ; then
        echo "ERROR: $TARGETDEV is not a raw device but a partition"
        exit 2
    fi

    if "${BINDIR}/lsblk" -o MOUNTPOINTS --noheadings "$TARGETDEV" | "${BINDIR}/grep" -q -E -v "^\$" ; then
        echo "ERROR: $TARGETDEV (or a partition of it) is currently mounted"
        exit 2
    fi

    KNAME=$("${BINDIR}/lsblk" -o KNAME --noheadings --nodeps "$TARGETDEV")
    if "${BINDIR}/find" "/sys/block/${KNAME}/" -path "*/holders/*" | "${BINDIR}/grep" -q -E -v "^\$" ; then
        echo "ERROR: $TARGETDEV (or a partition of it) is currently used in the kernel (e.g. device mapper)"
        exit 2
    fi

    if "${BINDIR}/lsblk" -o RO --noheadings --nodeps "$TARGETDEV" | "${BINDIR}/grep" -q "1" ||
        "${BINDIR}/lsblk" -o TYPE --noheadings --nodeps "$TARGETDEV" | "${BINDIR}/grep" -q -E "^rom" ; then
        echo "ERROR: $TARGETDEV is read-only"
        exit 2
    fi

    if ! "${BINDIR}/lsblk" -o HOTPLUG --noheadings --nodeps "$TARGETDEV" | "${BINDIR}/grep" -q "1" ; then
        echo "WARNING: $TARGETDEV is not a removable or hotplug device"
        
        read -p "Are you sure you want to overwrite it (y/n)? " answer
        case ${answer:0:1} in
            y|Y )
                echo Ok
            ;;
            * )
                echo "Aborting"
                exit 1
            ;;
        esac
    fi

    return
}

select_targetdev()
{
    # find all suitable hotplug block devices and show them in a dialog
    
    declare -a blockdevs
    readarray -t blockdevs < <("${BINDIR}/lsblk" -o KNAME --noheadings --nodeps)

    declare -a devmenu
    devmenu=( )
    for d in "${blockdevs[@]}" ; do
    
        if ! "${BINDIR}/lsblk" -o HOTPLUG --noheadings --nodeps "/dev/${d}" | "${BINDIR}/grep" -q "1" ; then
            # we only want to show hotplug / removable block devices
            continue
        fi

        if "${BINDIR}/lsblk" -o RO --noheadings --nodeps "/dev/${d}" | "${BINDIR}/grep" -q "1" ||
           "${BINDIR}/lsblk" -o TYPE --noheadings --nodeps "/dev/${d}" | "${BINDIR}/grep" -q -E "^rom" ; then
            # ignore read-only devices like cdroms
            continue
        fi
        
        TARGETDEVSIZE=$("${BINDIR}/lsblk" -o SIZE --bytes --noheadings --nodeps "/dev/${d}")
        # require gracious 50 MB tolerance to account for filesystem metadata and partitioning
        if [[ "${TARGETDEVSIZE}" -lt $[$ISOSIZE+52428800] ]]; then
            # we only want to show devices large enough
            continue
        fi

        TARGETDEVHUMANSIZE=$("${BINDIR}/lsblk" -o SIZE --noheadings --nodeps "/dev/${d}")
        # strip leading whitespace
        TARGETDEVHUMANSIZE="${TARGETDEVHUMANSIZE#"${TARGETDEVHUMANSIZE%%[![:space:]]*}"}"
        # strip trailing whitespace
        TARGETDEVHUMANSIZE="${TARGETDEVHUMANSIZE%"${TARGETDEVHUMANSIZE##*[![:space:]]}"}"

        # show this device -> read out it's model and manufacturer
        
        MODEL=$("${BINDIR}/lsblk" -o MODEL --bytes --noheadings --nodeps "/dev/${d}")
        VENDOR=$("${BINDIR}/lsblk" -o VENDOR --bytes --noheadings --nodeps "/dev/${d}")
        
        # replace all potentially dangerous characters with "_" - just to be sure, badusb is a thing...
        MODEL="${MODEL//[^[0-9A-Za-z_ .,+*/?<=>@:-]]/_}"
        VENDOR="${VENDOR//[^[0-9A-Za-z_ .,+*/?<=>@:-]]/_}"
        
        # strip trailing whitespace
        MODEL="${MODEL%"${MODEL##*[![:space:]]}"}"  
        VENDOR="${VENDOR%"${VENDOR##*[![:space:]]}"}"  
        
        # don't show vendor if just some hex code
        if [[ "$VENDOR" =~ ^0x[0-9a-fA-F]+ ]]; then
            VENDOR=""
        fi
        
        # don't show vendor if it is contained in the model too
        if echo "$MODEL" | grep -i -q "$VENDOR" ; then
            VENDOR=""
        fi

        if [[ -n "$VENDOR" ]]; then
            devmenu+=("/dev/${d}")
            devmenu+=("${VENDOR} ${MODEL} (${TARGETDEVHUMANSIZE}B)")
        else
            devmenu+=("/dev/${d}")
            devmenu+=("${MODEL} (${TARGETDEVHUMANSIZE}B)")
        fi
    done
    
    if [[ ${#devmenu[@]} -eq 0 ]]; then
        echo "ERROR: no suitable target devices found"
        echo "You can manually specify the target device with the --target=<DEVICE-PATH> option"
        exit 1
    fi
    
    # let user select between all devices in a ncurses dialog
    exec 3>&1;
    exitcode=0
    SELECTED=$(dialog --erase-on-exit --title "Select target device" \
        --menu "Select device to write SystemRescue to" 0 0 0 "${devmenu[@]}" 2>&1 1>&3) || exitcode=$?
    exec 3>&-

    if [[ "$exitcode" -ne 0 ]] || [[ -z "$SELECTED" ]]; then
        echo "Aborted"
        exit 1
    fi
    
    TARGETDEV="${SELECTED}"

    return
}

clean_tmpdir()
{
    # clean up our temp dir, called via EXIT trap
    "${BINDIR}/rm" -rf "${TMPDIR}"
}

create_tmpdir()
{
    # create tmpdir to unpack to
    
    # if not configured we use /tmp
    if ! [[ -v TMPDIR ]] || [[ -z "$TMPDIR" ]]; then
        TMPDIR=/tmp
    fi

    if ! [[ -r "$TMPDIR" && -w "$TMPDIR" ]]; then
        echo "ERROR: not enough permissions on $TMPDIR"
        exit 2
    fi
    
    # check free space on temp dir
    TMPSPACE=$("${BINDIR}/df" --block-size=1 --output=avail "$TMPDIR" | "${BINDIR}/grep" -v "Avail")
    # require gracious 50 MB tolerance to account for filesystem metadata and inefficiency
    if [[ "${TMPSPACE}" -lt $[$ISOSIZE+52428800] ]]; then
        echo "ERROR: not enough space on $TMPDIR"
        exit 2
    fi

    # always create a subdir below a given TMPDIR for security/reliability reasons
    TMPDIR=$("${BINDIR}/mktemp" --tmpdir="${TMPDIR}" --directory tmp.XXXXXXXXXX)

    # always clean up our tmpdir when the script exits
    trap clean_tmpdir EXIT
}

############# SCRIPT STARTS HERE ####################

parse_args "$@"

check_iso
create_tmpdir

if [[ -n "$TARGETDEV" ]]; then
    # we got $TARGETDEV as a cmdline option, check if valid
    check_targetdev
else
    # no $TARGETDEV option, let user select one in a dialog
    select_targetdev
    check_targetdev
fi

echo "Unpacking iso image..."

# unpack iso image
"${BINDIR}/mkdir" -p "${TMPDIR}/filesystem"
"${BINDIR}/xorriso" -drive_access "shared:readonly" -indev "${ISOIMAGE}" -pvd_info $VERBOSE >"${TMPDIR}/meta-pvd" 2>/dev/null
"${BINDIR}/xorriso" -osirrox on -drive_access "shared:readonly" -indev "${ISOIMAGE}" -extract / "${TMPDIR}/filesystem" $VERBOSE 2>/dev/null

# TODO: better check that is not hardcoded on version, but detects syslinux version, iso layout and architecture
if ! [[ -f "${TMPDIR}/filesystem/sysresccd/VERSION" ]] || \
   ! [[ -d "${TMPDIR}/filesystem/sysresccd/x86_64" ]] || \
   ! "${BINDIR}/grep" -q "9.05" "${TMPDIR}/filesystem/sysresccd/VERSION" ; then
    echo "ERROR: iso image is not compatible with this script. It only works with SystemRescue 9.05 x86_64"
    exit 2
fi

PARTLABEL=$("${BINDIR}/grep" -E "Volume Id *:" "${TMPDIR}/meta-pvd" | "${BINDIR}/sed" -e "s/^Volume Id *: \(.*\)/\1/")

if ! echo "$PARTLABEL" | "${BINDIR}/grep" -q "^RESCUE" ; then
    echo "ERROR: can't read iso volume label"
    exit 1
fi

read -p "Are you sure you want to overwrite all content of $TARGETDEV (y/n)? " answer
case ${answer:0:1} in
    y|Y )
        echo Ok
    ;;
    * )
        echo "Aborting"
        exit 1
    ;;
esac

echo "Partitioning and formatting target device..."

# size not given means until the end of the device
"${BINDIR}/sfdisk" --wipe always --wipe-partitions always --no-tell-kernel --quiet "${TARGETDEV}" 2>/dev/null <<EOF
label: dos
unit: sectors
sector-size: 512

img1 : start=        2048, type=c, bootable
EOF

# FAT tools need to convert to/from codepage 850, the dos default
# we bring our own gconv libs for our glibc, use them
export GCONV_PATH="${APPDIR}/usr/lib/gconv"

# the filesystem begins at sector 2048, fix backup boot sector at 6 (see below)
"${BINDIR}/mkfs.fat" -F 32 -b 6 -n "${PARTLABEL}" --offset=2048 -I "${TARGETDEV}" >/dev/null

echo "Copying files..."

# copy all files from the iso onto the fat partition
declare -a firstlevel
readarray -t firstlevel < <("${BINDIR}/find" "${TMPDIR}/filesystem" -maxdepth 1 -mindepth 1)
# TODO: print progress, probably by patching mcopy to print a "." every megabyte or something similar
"${BINDIR}/mcopy" -spQm "${firstlevel[@]}" -i "${TARGETDEV}@@1048576" ::/

echo "Installing syslinux bootloader..."

# install syslinux on target dev
# forks several mtools programs, so we need to set the PATH to our dir only
PATH="${BINDIR}" "${BINDIR}/syslinux" --directory /sysresccd/boot/syslinux/ --install "${TARGETDEV}" --offset 1048576

# install the syslinux MBR, boot from partition 1
printf '\1' | "${BINDIR}/cat" "${APPDIR}/usr/lib/syslinux/bios/altmbr.bin" - | "${BINDIR}/dd" bs=440 count=1 iflag=fullblock conv=notrunc "of=${TARGETDEV}" 2>/dev/null

# syslinux only installs itself to the primary fat boot sector, not the backup boot sector
# the backup boot sector is at logical sector 6 of the fat32 filesystem, the primary at sector 1
# copy it over so we get a properly clean filesystem
"${BINDIR}/dd" bs=512 count=1 iseek=2048 "if=${TARGETDEV}" "of=${TMPDIR}/fatboosect.bin" 2>/dev/null
"${BINDIR}/dd" bs=512 count=1 oseek=2054 conv=notrunc,nocreat "if=${TMPDIR}/fatboosect.bin" "of=${TARGETDEV}" 2>/dev/null

# write caches to drive
# usually does not apply when doing direct access to the device handle, but we want to be sure
"${BINDIR}/sync"

echo "Verifying data..."

# TODO: add patched version of fsck.vfat that can read from offsets and do a filesystem check

# verify output media content
"${BINDIR}/find" "${TMPDIR}/filesystem/" -type f -printf "%P\n" | while read -r line; do
    if ! "${BINDIR}/mcopy" -i "${TARGETDEV}@@1048576" "::/${line}" - | "${BINDIR}/cmp" - "${TMPDIR}/filesystem/${line}"; then
        echo "ERROR: verification mismatch for file ${line}"
        exit 3
    fi
done

echo "Success"
