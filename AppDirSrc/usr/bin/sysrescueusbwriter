# no shebang supported here
# can only be directly called with the correct shell (=packaged version of bash)
#
# sysrescueusbwriter - write an iso image of SystemRescue to USB media
# 
# Author: Gerd v. Egidy
# SPDX-License-Identifier: GPL-3.0-or-later
#
# https://gitlab.com/systemrescue/systemrescue-sources/-/issues/284

# TODO: add proper argument handling

ISOIMAGE="$1"
TARGETDEV="$2"
VERBOSE=""

# TODO: check for all programs we call from here that aren't packaged in the AppImage

# TODO: both paths could be relative to $OWD, resolve them to absolute

if ! [[ -f "$ISOIMAGE" ]]; then
    echo "ERROR: No such file: $ISOIMAGE"
    exit 1
fi

if ! [[ -b "$TARGETDEV" ]]; then
    echo "ERROR: No such block device: $TARGETDEV"
    exit 1
fi

# abort on failures
set -o errexit -o pipefail -o noclobber -o nounset

if ! [[ -r "$ISOIMAGE" ]]; then
    echo "ERROR: not enough permissions to read $ISOIMAGE"
    exit 2
fi

if ! [[ -r "$TARGETDEV" && -w "$TARGETDEV" ]]; then
    echo "ERROR: not enough permissions to access $TARGETDEV"
    exit 2
fi

TARGETDEVSIZE=$("${APPDIR}/usr/bin/lsblk" -o SIZE --bytes --noheadings --nodeps "$TARGETDEV")
ISOSIZE=$(stat --format=%s "$ISOIMAGE")
# require gracious 50 MB tolerance to account for filesystem metadata and partitioning
if [[ "${TARGETDEVSIZE}" -lt $[$ISOSIZE+52428800] ]]; then
    echo "ERROR: $TARGETDEV is too small for the given iso image"
    exit 2
fi

if "${APPDIR}/usr/bin/lsblk" -o PKNAME --noheadings --nodeps "$TARGETDEV" | grep -q -E -v "^\$" ; then
    echo "ERROR: $TARGETDEV is not a raw device but a partition"
    exit 2
fi

if "${APPDIR}/usr/bin/lsblk" -o MOUNTPOINTS --noheadings "$TARGETDEV" | grep -q -E -v "^\$" ; then
    echo "ERROR: $TARGETDEV (or a partition of it) is currently mounted"
    exit 2
fi

if "${APPDIR}/usr/bin/lsblk" -o RO --noheadings --nodeps "$TARGETDEV" | grep -q "1" ; then
    echo "ERROR: $TARGETDEV is read-only"
    exit 2
fi

if ! "${APPDIR}/usr/bin/lsblk" -o HOTPLUG --noheadings --nodeps "$TARGETDEV" | grep -q "1" ; then
    echo "WARNING: $TARGETDEV is not a removable or hotplug device"
    
    read -p "Are you sure you want to overwrite it (y/n)? " answer
    case ${answer:0:1} in
        y|Y )
            echo Ok
        ;;
        * )
            echo "Aborting"
            exit 1
        ;;
    esac
fi

# check if we really have an iso file as source and not something else
if ! "${APPDIR}/usr/bin/xorriso" -drive_access "shared:readonly" -indev "${ISOIMAGE}" -toc >/dev/null 2>&1 ||
    "${APPDIR}/usr/bin/xorriso" -drive_access "shared:readonly" -indev "${ISOIMAGE}" -toc 2>&1 | grep -E "(is blank|Drive address .* rejected)"; then
    echo "ERROR: $ISOIMAGE is not a valid ISO file"
    exit 3
fi

# TODO: opportunistic checkisomd5 verify

# create tmpdir to unpack to
# default to below /tmp, but allow to change with $TMPDIR
if ! [[ -v TMPDIR ]] || [[ -z "$TMPDIR" ]]; then
    TMPDIR=/tmp
fi

# check free space on temp dir
TMPSPACE=$("${APPDIR}/usr/bin/df" --block-size=1 --output=avail "$TMPDIR" | grep -v "Avail")
# require gracious 50 MB tolerance to account for filesystem metadata and inefficiency
if [[ "${TMPSPACE}" -lt $[$ISOSIZE+52428800] ]]; then
    echo "ERROR: not enough space on $TMPDIR"
    exit 2
fi

# always create a subdir below a given TMPDIR for security/reliability reasons
TMPDIR=$("${APPDIR}/usr/bin/mktemp" --tmpdir="${TMPDIR}" --directory tmp.XXXXXXXXXX)
# errors during main execution will leave the TMPDIR behind
# useful for finding out what went wrong, but has to be cleaned manually

echo "Unpacking iso image..."

# unpack iso image
mkdir -p "${TMPDIR}/filesystem"
"${APPDIR}/usr/bin/xorriso" -drive_access "shared:readonly" -indev "${ISOIMAGE}" -pvd_info $VERBOSE >"${TMPDIR}/meta-pvd" 2>/dev/null
"${APPDIR}/usr/bin/xorriso" -osirrox on -drive_access "shared:readonly" -indev "${ISOIMAGE}" -extract / "${TMPDIR}/filesystem" $VERBOSE 2>/dev/null

# TODO: better check that is not hardcoded on version, but detects syslinux version, iso layout and architecture
if ! [[ -f "${TMPDIR}/filesystem/sysresccd/VERSION" ]] || \
   ! grep -q "9.05" "${TMPDIR}/filesystem/sysresccd/VERSION" ; then
    echo "ERROR: iso image is not compatible with this script. It only works with SystemRescue 9.05"
    exit 2
fi

PARTLABEL=$(grep -E "Volume Id *:" "${TMPDIR}/meta-pvd" | sed -e "s/^Volume Id *: \(.*\)/\1/")

if ! echo "$PARTLABEL" | grep -q "^RESCUE" ; then
    echo "ERROR: can't read iso volume label"
    exit 1
fi

read -p "Are you sure you want to overwrite all content of $TARGETDEV (y/n)? " answer
case ${answer:0:1} in
    y|Y )
        echo Ok
    ;;
    * )
        echo "Aborting"
        exit 1
    ;;
esac

# partition & format target dev
# size not given means until the end of the device
"${APPDIR}/usr/bin/sfdisk" --wipe always --wipe-partitions always --quiet "${TARGETDEV}" <<EOF
label: dos
unit: sectors
sector-size: 512

img1 : start=        2048, type=c, bootable
EOF

# the filesystem begins at sector 2048, fix backup boot sector at 6 (see below)
"${APPDIR}/usr/bin/mkfs.fat" -F 32 -b 6 -n "${PARTLABEL}" --offset=2048 -I "${TARGETDEV}" >/dev/null

echo "Copying files..."

# copy all files
# TODO: quote source dir, probably need to list all first level contents separately
# TODO: print progress, probably by patching mcopy to print a "." every megabyte or something similar
"${APPDIR}/usr/bin/mcopy" -spQm ${TMPDIR}/filesystem/* -i "${TARGETDEV}@@1048576" ::/

echo "Installing syslinux bootloader..."

# install syslinux on target dev
"${APPDIR}/usr/bin/syslinux" --directory /sysresccd/boot/syslinux/ --install "${TARGETDEV}" --offset 1048576

# install the syslinux MBR, boot from partition 1
printf '\1' | cat "${APPDIR}/usr/lib/syslinux/bios/altmbr.bin" - | "${APPDIR}/usr/bin/dd" bs=440 count=1 iflag=fullblock conv=notrunc "of=${TARGETDEV}" 2>/dev/null

# syslinux only installs itself to the primary fat boot sector, not the backup boot sector
# the backup boot sector is at logical sector 6 of the fat32 filesystem, the primary at sector 1
# copy it over so we get a properly clean filesystem
"${APPDIR}/usr/bin/dd" bs=512 count=1 iseek=2048 "if=${TARGETDEV}" "of=${TMPDIR}/fatboosect.bin" 2>/dev/null
"${APPDIR}/usr/bin/dd" bs=512 count=1 oseek=2054 conv=notrunc,nocreat "if=${TMPDIR}/fatboosect.bin" "of=${TARGETDEV}" 2>/dev/null

# write caches to drive
# usually does not apply when doing direct access to the device handle, but we want to be sure
sync

echo "Verifying data..."

# TODO: add patched version of fsck.vfat that can read from offsets and do a filesystem check

# verify output media content
"${APPDIR}/usr/bin/find" "${TMPDIR}/filesystem/" -type f -printf "%P\n" | while read -r line; do
    if ! "${APPDIR}/usr/bin/mcopy" -i "${TARGETDEV}@@1048576" "::/${line}" - | "${APPDIR}/usr/bin/cmp" - "${TMPDIR}/filesystem/${line}"; then
        echo "ERROR: verification mismatch for file ${line}"
        exit 3
    fi
done

# everything successful, so we can clean up our temp dir
rm -rf "${TMPDIR}"

echo "Success"
