# no shebang supported here
# can only be directly called with the correct shell (=packaged version of bash)
#
# sysrescueusbwriter - write an iso image of SystemRescue to USB media
# 
# Author: Gerd v. Egidy
# SPDX-License-Identifier: GPL-3.0-or-later
#
# https://gitlab.com/systemrescue/systemrescue-sources/-/issues/284

BINDIR="${APPDIR}/usr/bin"

print_help()
{
    echo "sysrescueusbwriter - write an iso image of SystemRescue to USB media"
    echo ""
    echo "Usage:"
    echo "sysrescueusbwriter-x86_64.AppImage [-t|--target=<DEVICE-PATH>] <ISO-FILE>"
    echo ""
    echo "--target=<DEVICE-PATH>      Device file of the USB media you want to write to."
    echo "                            Something like /dev/sdb"
    echo ""
    echo "<ISO-FILE>                  ISO image of SystemRescue"
    echo ""
    echo "See https://gitlab.com/systemrescue/systemrescue-sources/-/issues/284 for details."
    
    return
}

# error while parsing commandline parameters
argument_error()
{
    echo "$1"
    echo
    echo "---------------------------------"
    echo
    print_help
    exit 2
}

parse_args()
{
    # adapted from https://stackoverflow.com/a/29754866 by Robert Siemer
    # version edited Mar 4 '21 at 0:11, licensed under CC BY-SA 4.0 due to Stackoverflow Terms of Service
    # https://creativecommons.org/licenses/by-sa/4.0/

    # show help when no arguments given
    [[ $# -eq 0 ]] && { print_help ; exit 0 ; }
    
    # -allow a command to fail with !’s side effect on errexit
    # -use return value from ${PIPESTATUS[0]}, because ! hosed $?
    ! "${BINDIR}/getopt" --test > /dev/null 
    if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
        echo 'ERROR: `getopt --test` failed in this environment'
        exit 1
    fi

    local OPTIONS="t:h"
    local LONGOPTS="target:,help"

    # option variables as globals, set to default values
    declare -g TARGETDEV=""
    declare -g ISOIMAGE=""
    declare -g VERBOSE=""
    
    # -regarding ! and PIPESTATUS see above
    # -temporarily store output to be able to check for errors
    # -activate quoting/enhanced mode (e.g. by writing out “--options”)
    # -pass arguments only via   -- "$@"   to separate them correctly
    ! PARSED=$("${BINDIR}/getopt" --options=$OPTIONS --longoptions=$LONGOPTS --name "$0" -- "$@")
    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        # e.g. return value is 1
        #  then getopt has complained about wrong arguments to stdout
        echo
        print_help
        exit 2
    fi
    # read getopt’s output this way to handle the quoting right:
    eval set -- "$PARSED"

    while true; do
        case "$1" in
            -t|--target)
                TARGETDEV="$2"
                shift 2
                ;;
            -h|--help)
                print_help
                exit 0
                ;;
            --)
                shift
                break
                ;;
            *)
                echo "ERROR: Argument parsing logic bug"
                exit 2
                ;;
        esac
    done

    # handle positional arguments 
    if [[ $# -lt 1 ]]; then
        argument_error "ERROR: iso image option missing or empty"
        exit 1
    fi
    if [[ $# -gt 1 ]]; then
        argument_error "ERROR: too many positional arguments"
        exit 1
    fi
    ISOIMAGE="$1"
    
    [[ -z "$TARGETDEV" ]] && argument_error "ERROR: target device option missing or empty"
    [[ -z "$ISOIMAGE" ]] && argument_error "ERROR: iso image option missing or empty"

    return
}

parse_args "$@"

if [[ "$ISOIMAGE" =~ ^[^/] ]]; then
    # path relative to the dir we were originally called from
    ISOIMAGE="${OWD}/${ISOIMAGE}"
fi

if [[ "$TARGETDEV" =~ ^[^/] ]]; then
    # path relative to the dir we were originally called from
    TARGETDEV="${OWD}/${TARGETDEV}"
fi

if ! [[ -f "$ISOIMAGE" ]]; then
    echo "ERROR: No such file: $ISOIMAGE"
    exit 1
fi

if ! [[ -b "$TARGETDEV" ]]; then
    echo "ERROR: No such block device: $TARGETDEV"
    exit 1
fi

# abort on failures
set -o errexit -o pipefail -o noclobber -o nounset

if ! [[ -r "$ISOIMAGE" ]]; then
    echo "ERROR: not enough permissions to read $ISOIMAGE"
    exit 2
fi

if ! [[ -r "$TARGETDEV" && -w "$TARGETDEV" ]]; then
    echo "ERROR: not enough permissions to access $TARGETDEV"
    exit 2
fi

TARGETDEVSIZE=$("${BINDIR}/lsblk" -o SIZE --bytes --noheadings --nodeps "$TARGETDEV")
ISOSIZE=$("${BINDIR}/stat" --format=%s "$ISOIMAGE")
# require gracious 50 MB tolerance to account for filesystem metadata and partitioning
if [[ "${TARGETDEVSIZE}" -lt $[$ISOSIZE+52428800] ]]; then
    echo "ERROR: $TARGETDEV is too small for the given iso image"
    exit 2
fi

if "${BINDIR}/lsblk" -o PKNAME --noheadings --nodeps "$TARGETDEV" | "${BINDIR}/grep" -q -E -v "^\$" ; then
    echo "ERROR: $TARGETDEV is not a raw device but a partition"
    exit 2
fi

if "${BINDIR}/lsblk" -o MOUNTPOINTS --noheadings "$TARGETDEV" | "${BINDIR}/grep" -q -E -v "^\$" ; then
    echo "ERROR: $TARGETDEV (or a partition of it) is currently mounted"
    exit 2
fi

KNAME=$("${BINDIR}/lsblk" -o KNAME --noheadings --nodeps "$TARGETDEV")
if "${BINDIR}/find" "/sys/block/${KNAME}/" -path "*/holders/*" | "${BINDIR}/grep" -q -E -v "^\$" ; then
    echo "ERROR: $TARGETDEV (or a partition of it) is currently used in the kernel (e.g. device mapper)"
    exit 2
fi

if "${BINDIR}/lsblk" -o RO --noheadings --nodeps "$TARGETDEV" | "${BINDIR}/grep" -q "1" ; then
    echo "ERROR: $TARGETDEV is read-only"
    exit 2
fi

if ! "${BINDIR}/lsblk" -o HOTPLUG --noheadings --nodeps "$TARGETDEV" | "${BINDIR}/grep" -q "1" ; then
    echo "WARNING: $TARGETDEV is not a removable or hotplug device"
    
    read -p "Are you sure you want to overwrite it (y/n)? " answer
    case ${answer:0:1} in
        y|Y )
            echo Ok
        ;;
        * )
            echo "Aborting"
            exit 1
        ;;
    esac
fi

# check if we really have an iso file as source and not something else
if ! "${BINDIR}/xorriso" -drive_access "shared:readonly" -indev "${ISOIMAGE}" -toc >/dev/null 2>&1 ||
    "${BINDIR}/xorriso" -drive_access "shared:readonly" -indev "${ISOIMAGE}" -toc 2>&1 | "${BINDIR}/grep" -E "(is blank|Drive address .* rejected)"; then
    echo "ERROR: $ISOIMAGE is not a valid ISO file"
    exit 3
fi

# TODO: opportunistic checkisomd5 verify

# create tmpdir to unpack to
# default to below /tmp, but allow to change with $TMPDIR
if ! [[ -v TMPDIR ]] || [[ -z "$TMPDIR" ]]; then
    TMPDIR=/tmp
fi

# check free space on temp dir
TMPSPACE=$("${BINDIR}/df" --block-size=1 --output=avail "$TMPDIR" | "${BINDIR}/grep" -v "Avail")
# require gracious 50 MB tolerance to account for filesystem metadata and inefficiency
if [[ "${TMPSPACE}" -lt $[$ISOSIZE+52428800] ]]; then
    echo "ERROR: not enough space on $TMPDIR"
    exit 2
fi

# always create a subdir below a given TMPDIR for security/reliability reasons
TMPDIR=$("${BINDIR}/mktemp" --tmpdir="${TMPDIR}" --directory tmp.XXXXXXXXXX)
# errors during main execution will leave the TMPDIR behind
# useful for finding out what went wrong, but has to be cleaned manually

echo "Unpacking iso image..."

# unpack iso image
"${BINDIR}/mkdir" -p "${TMPDIR}/filesystem"
"${BINDIR}/xorriso" -drive_access "shared:readonly" -indev "${ISOIMAGE}" -pvd_info $VERBOSE >"${TMPDIR}/meta-pvd" 2>/dev/null
"${BINDIR}/xorriso" -osirrox on -drive_access "shared:readonly" -indev "${ISOIMAGE}" -extract / "${TMPDIR}/filesystem" $VERBOSE 2>/dev/null

# TODO: better check that is not hardcoded on version, but detects syslinux version, iso layout and architecture
if ! [[ -f "${TMPDIR}/filesystem/sysresccd/VERSION" ]] || \
   ! [[ -d "${TMPDIR}/filesystem/sysresccd/x86_64" ]] || \
   ! "${BINDIR}/grep" -q "9.05" "${TMPDIR}/filesystem/sysresccd/VERSION" ; then
    echo "ERROR: iso image is not compatible with this script. It only works with SystemRescue 9.05 x86_64"
    exit 2
fi

PARTLABEL=$("${BINDIR}/grep" -E "Volume Id *:" "${TMPDIR}/meta-pvd" | "${BINDIR}/sed" -e "s/^Volume Id *: \(.*\)/\1/")

if ! echo "$PARTLABEL" | "${BINDIR}/grep" -q "^RESCUE" ; then
    echo "ERROR: can't read iso volume label"
    exit 1
fi

read -p "Are you sure you want to overwrite all content of $TARGETDEV (y/n)? " answer
case ${answer:0:1} in
    y|Y )
        echo Ok
    ;;
    * )
        echo "Aborting"
        exit 1
    ;;
esac

# partition & format target dev
# size not given means until the end of the device
"${BINDIR}/sfdisk" --wipe always --wipe-partitions always --quiet "${TARGETDEV}" <<EOF
label: dos
unit: sectors
sector-size: 512

img1 : start=        2048, type=c, bootable
EOF

# the filesystem begins at sector 2048, fix backup boot sector at 6 (see below)
"${BINDIR}/mkfs.fat" -F 32 -b 6 -n "${PARTLABEL}" --offset=2048 -I "${TARGETDEV}" >/dev/null

echo "Copying files..."

# copy all files from the iso onto the fat partition
declare -a firstlevel
readarray -t firstlevel < <("${BINDIR}/find" "${TMPDIR}/filesystem" -maxdepth 1 -mindepth 1)
# TODO: print progress, probably by patching mcopy to print a "." every megabyte or something similar
"${BINDIR}/mcopy" -spQm "${firstlevel[@]}" -i "${TARGETDEV}@@1048576" ::/

echo "Installing syslinux bootloader..."

# install syslinux on target dev
"${BINDIR}/syslinux" --directory /sysresccd/boot/syslinux/ --install "${TARGETDEV}" --offset 1048576

# install the syslinux MBR, boot from partition 1
printf '\1' | "${BINDIR}/cat" "${APPDIR}/usr/lib/syslinux/bios/altmbr.bin" - | "${BINDIR}/dd" bs=440 count=1 iflag=fullblock conv=notrunc "of=${TARGETDEV}" 2>/dev/null

# syslinux only installs itself to the primary fat boot sector, not the backup boot sector
# the backup boot sector is at logical sector 6 of the fat32 filesystem, the primary at sector 1
# copy it over so we get a properly clean filesystem
"${BINDIR}/dd" bs=512 count=1 iseek=2048 "if=${TARGETDEV}" "of=${TMPDIR}/fatboosect.bin" 2>/dev/null
"${BINDIR}/dd" bs=512 count=1 oseek=2054 conv=notrunc,nocreat "if=${TMPDIR}/fatboosect.bin" "of=${TARGETDEV}" 2>/dev/null

# write caches to drive
# usually does not apply when doing direct access to the device handle, but we want to be sure
"${BINDIR}/sync"

echo "Verifying data..."

# TODO: add patched version of fsck.vfat that can read from offsets and do a filesystem check

# verify output media content
"${BINDIR}/find" "${TMPDIR}/filesystem/" -type f -printf "%P\n" | while read -r line; do
    if ! "${BINDIR}/mcopy" -i "${TARGETDEV}@@1048576" "::/${line}" - | "${BINDIR}/cmp" - "${TMPDIR}/filesystem/${line}"; then
        echo "ERROR: verification mismatch for file ${line}"
        exit 3
    fi
done

# everything successful, so we can clean up our temp dir
"${BINDIR}/rm" -rf "${TMPDIR}"

echo "Success"
